hey what's up guys today we're going to be building a W app end to end My name is Yodan and I'm the head of apps at and I want to show you how to build a W app that takes advantage of our orth payments and app store We're going to build an app that allows creators to post questions and users to answer them and get paid in the process I'm going to show you how to do this all end to end in this video Okay the first thing we want to do is we want to go to dev.wop.com and hit on the get started section Then we can take this command and run it in our terminal I'm going to use PNPX just cuz I prefer using PNPM here but npm works fine too After this is installed we're going to CD into our new directory and open it with cursor This will give us the W app template We can now run this using PNPM def This will run it on localhost 3000 One thing to note here is that the original port is 49,000 but just use 3,000 for now Now we have our app set up We don't have any environment variables and we don't have it linked up with yet So what we want to do is we want to go to our dashboard and make sure that we have an app in our dashboard What you can see here is I've gone up and I've onboarded onto W I've created a company Once I'm in the company I can click on the developer section and then I can hit create app down here I'm going to give this app a title called creator setting app save And that'll put me on this page This page shows me my API keys my app information and it's the one place you want to go to configure things about your app As you can see we're working on adding more and more things that apps can do across the platform and you'll find those all on this page For now I'm just going to copy the environment variables and paste them into my environment file I'm going to make a new file called env.development.local and paste those in here Hit save and close that Now we can restart our app and open it up again We should see that we now have our secrets and IDs correctly displayed here Now what we need to do is we need to install our app into our W So I'm going to click here and you can see that I've already created a W on the platform I'm just going to add it in Now we'll see this This is opening the production version of app which we haven't deployed yet We just run it on local host So while you're developing what you want to do is you want to hit this settings icon at the top right of the screen and then you want to hit local host here Now we can see our app rendering perfectly So this is the default app view that we show and we can fetch the user information We can check whether they have access to this instance of our app We can see what whether they're an admin or a user and we get information about the user and about the experience and about the company So let's get this deployed in production and make sure that it works end to end Step one of getting our app to production is going to be making a GitHub repo So I'm just going to create a new GitHub repo and upload our code Hit new Just going to deploy it myself and I'll call it app creator beds Once we've created the GitHub repo what we can do is we can upload our code using the bottom bottom commands and just paste those in there and we should be good to go We can see on GitHub now that our code has been uploaded Now what we're going to do is we're going to make a Versel project and get our code live So I'm going to go to Vessel I'm going to create a new project and I'm going to sync up this repo that we just created One thing to note here is that we need to add the same environment variables that we added before So I'm just going to copy those out of our environment variable file Now we're deploying Okay while that's deploying what we can do is we can link our project locally to Versel So we can pull environment variables and keep everything in sync that way What I'm going to do is I'm going to run versel link and I'm going to hit yes here I'm going to say the project is in that organization I'll say that we're linking to an existing project and I'll copy the project name here Now it's linked and we can sync all of our environment variables using the versel enp.env.development.local And we can override the existing one And now our environment variables will be in sync between Versel and local which is very helpful for the next step By now our app is deployed to Versel and we can set up the production domain in So what we're going to do is we're going to copy this URL which is the URL that our app is deployed on and we're going to paste it into our creator dashboard here under base URL So just make sure that has a HTTPS And once we hit save our app is now live So what that means is we can change this back to production and we should see exactly the same screen once it loads for the first time There we go Now our app is live and anyone in my community can see it So now let's add some features Before we get started I'm going to install the dependencies that we'll need So we're going to use Drizzle and Superbase for our database And we're going to use Tailwind and Lucide React for some icons And we have some mist packages that we'll need to set things up I'm just going to install those using these two commands Those for our normal dependencies And this will be our dev dependencies Now let's set up our Drizzle schema and Superbase database so we can get a database going To do that I'll set up our drizzle.config.ts ts and just paste a basic configuration in here that'll read from our environment variables and then load our schema We don't have this lib db schema yet So let's go and create that new file lib/db/s schema.ts And now we can get started in here So our app is going to have three tables We'll need one to keep track of the games or the questions We'll need another one to keep track of the answers for each of the games And then we'll need a third one to keep track of the votes So essentially one game will have many answers and each answer will have many votes by all the different players that are playing Something I like to do with Drizzle is I like to make these timestamps helpers and that will allow every table to have a created at and updated at that stays in sync Another thing we're going to do is we're going to use CU ID for autogenerated IDs and that just keeps things random Now we can get started and add our tables The games table is going to have a ID It's going to have some text for the question and it's going to specify how much it'll cost to answer once When the user answers they're going to pay this amount and that'll add to the total pool sum for that game When the game ends and the creator chooses the correct answer all the people that voted for the correct answer will get the amount of money that was paid in for this game and it'll be split between everyone equally The people that chose the wrong answer lose out and that's how users can make money with a game Each game is going to have multiple answers So you'll have an answers table that has just the text for the answer and a link back to the game The game also has this correct answer field which will be set after the game finishes a completed at field to specify when the game stopped taking bids and we want to keep track of the user that created at and what experience ID the game is in The experience ID is the instance of the app being installed in a community So we could install this app twice and have two different experience IDs or two different running games We could also install it in another community which would be another experience and that allows you to customize your app per installation So that's why we're keeping track of it here so we can reference back and find the correct game for this experience The last table we'll need is we'll need the votes table This table will keep track of whether a user has voted and what answer that they voted for So we'll have an answer ID We'll put the game ID on it so we know which game it's from We'll keep track of the user ID that voted and we'll keep track of the amount that they paid and the amount that we received after fees Um this is so we can compute the sum for the game as the sum of all the received amounts of the votes per game ID And that'll help with accounting and paying out and funds later on We'll also make sure that a user can only vote once per game by adding this unique index And that's it Now what we need to do is we need to make it so we can connect to our database at runtime And to do that we'll add an index ts to our DB folder and we'll paste this boiler plate from drizzle This will pull in our Postgress URL and then it will create our DB and take the schema that we've just declared Now let's get this running on a real Superbase database To get Superbase up and running I'm going to go to Versel and I'm going to link Superbase and create a new project directly from Versel I'm going to go to settings integrations and I'll hit browse marketplace This will allow me to hit Superbase and install a database directly into my app When creating the database I'm going to name it exactly the same as my app here just to keep things organized Hit create Now we have our database created and we'll connect it to the project that we just made We'll make sure that we've selected development preview and production to make sure our database is available in all environments Let's connect Great Now that we're connected we can use the versel np pool command to get our database schema into our local configuration Once this is done we need to be able to migrate the tables that we just created into the production database So what we'll do is we'll set up a script in our package.json called db push and that will just be drizzle kit push They'll use Drizzle to apply the changes from our local files onto our database In production you might want to generate migrations and run them in a safer way but for development this is fine Let's run pnpm db push to push our schema changes to production Great Now that we have that set up we should be able to go to the Superbase dashboard and see and verify that our table's alive You can hit database here and hit tables and see that we have the answers games and votes table all live None of these have rows yet but let's get started and make our app So since we have no games available yet the first thing that I'm going to do is I'm going to create a screen where you can create a new game So I'm going to go to the app folder I'm going to hit the experiences route and we'll do everything scoped to an experience ID This route is going to be open by default when you open the app for the first time So as you can see in our community this here is rendered by this page and we get the experience ID passed in The experience ID um we can render that out um just so we can see it I'll render it out at the start We're currently looking at the production deployment but if I switch back to localhost and I run the dev server we'll see the uh changes that we do live I'll get started by running pnpmdev and then we can make sure that we've selected local host here and we have the port set to 3000 Now once we reload we'll see that we're rendering the experience ID here This experience ID matches up with the one that we have in the URL Now let's make a new page where you can create one of these games So I'll put it in the slashcreate subfolder and we can put our code in here One thing I'll do also is I'll add a layout to apply some common border bounding box For the layout we can just use this and we'll go over the websocket provider in a bit Once we have the layout set up we can set up our page by just adding some basic UI One thing that we do provide is we have the we have a UI kit that we export from atw/react/components This is frosted UI and you can find more information at storybook.wop.com This will show you all the components that are available and how to use them and what props they have For now we'll just use this And this is built on top of Radex UI So a lot of things that you're used to from Shad CNN should continue to work Um we have a form here We'll go through the action later Um and we'll just render this and make sure that it works So back in our app we can now add a button to go to that page So let's just add something here so we can head over to that page Button and we'll put it in a next link and the button will be from what React components If we click on this we should be here So this screen will let you input a question and we can specify how much money it'll cost to buy an answer essentially But we can't specify the answers yet For that we're going to need a client component So we can say this will be the answer option creator And we'll make this a client component And in that we'll just add a basic React component that allows you to create and update your answers available for that game So here we have an array of answers Each answer will add a form text input field into our form which means when we submit the form those answers will all get added Back in our create screen we can now add that answer option creator back in Now our UI has this So we can specify a few people in our answer Okay now that we have our form UI ready let's handle it on the server The first thing we always need to do when handling forms on the server is figure out who the user is you we can use the user authentication built into W apps To do that I'll make a file called authentication.ts and show you how you can grab the user ID from a request in Nex.jsuation.ts What we can do here is we can make a reusable function called verify user and we can make that cached by uh using the cache function from React So we'll export const verify user and we'll say that that will be cached just so on the through throughout if we call this multiple times per request we won't actually evaluate it multiple times inside here we'll take a few things we'll take an experience ID so we know what experience we want to verify the user for and we can take an optional um access level if you will and that can be admin So we can enforce that the user is an admin in this function The first thing that we want to do is we want to get our headers We can get those using the headers function from Nex.js Now we can get the user ID and we can get that from a helper file that's included in the template that exports this verify user token function This function has two modes One of it is throwing and the other one is non-throwing I prefer my verification functions to throw but you have the option to choose whichever one you want So now we can get the user ID from the headers by using await verify user token from our helper file and we can pass in our headers This will give us the user ID from the authenticated WP request Now we can make sure we can check what access level the user has for our experience So this will check what access level I have and it will be returned in this variable We can deconstruct it from here Just rename it So now if we pass admin to this it means that we should not let the request through if they have anything less than admin So what we can do is we can add this check here If we don't pass a required admin level we can just throw an error if they don't have access to the experience So if their current access level is no access we'll throw an error to make sure that we can't continue executing Now what we'll return is we'll return the user ID and access level from this function so we can use it later to make decisions in our code Now that we're authenticated let's create a server action to handle the form input from creating the game This server action will take in form data and it will pause it verify the user and handle it So we'll just make a small helper function here that will assert whether something is a string and then we can get some fields from our form that we created earlier We can also get the user ID and we can make sure that they are an admin by passing this second parameter This will enforce that only admins can create games while users of the WP can vote on games Now we can use standard drizzle to um query the games table and find the first game that um is not completed yet So this will enforce that we can only create a game if there's no other ongoing existing game already Um these functions we can just import from Drizzle Now what we can do is we can create the new game in a database transaction to make sure that the game is created or not created all in one atomic operation One thing that we still need to do is we need to get the answers from the form input For that we can create a helper function to pass those out of the form data When we made these answers we added we put them in as answer- option- index We can which we can see here in the creator The name of the text field is answer option index So to pause them what I'm going to do is I'm going to loop through the first 20 indexes that could exist This will limit the amount of answers you can add And I will make sure that the answer is a string and I'll pass it out of the form data as this and add it to this array And this will return a string array of all the answers in the form data So what we can do is we can pass those out up here and then we can insert them into the answers table in the second part of the transaction And now we can return the game Now after we've created the game we want to redirect the user to the home to the home screen where we'll show the current ongoing game which will be this one The redirect function is from next navigation Now if we refresh we should be able to create a game all from this UI So we can ask who will be the next president We'll make it $2 to answer and we'll say Trump or Elon One thing we need to do before we can run this is we need to say that the action of the form is the create game method or the create game server action And what we need to do is we need to annotate this file with use server to make sure that this is a server action So we can ask who will win the typing competition We'll put an answer cost of two and we'll say Cameron or red After we create this game we should be redirected to the homepage and we should have a new game in the table We can verify this here by checking the games table and the answers table in superbase So you can see that we have two answer rows and one game row And if we click into this we can view the games table here and we can see our question that we've added here Now let's render the question in the main screen of the app So we'll go back and we'll create an action a server action to load the data in load I'm just going to paste what I already have and explain and walk through the code with you This type will give us the data that's in the table by using our schema as a source of truth And what we'll do is we'll extend it by adding a total pool sum here which is a computed column of the sum of all the answers That way we'll know how much money has been paid into that instance of the game We also want to know how many answers there were and what answer we have voted with So we'll return the entire object as a game a list of answers which is the answer ID the answer and the vote count as well as an optional string that specifies the answer ID that the current user is voted with So we can show that to them in the UI Um what we're going to do first is reuse our verify user function Although this time we're not passing in the admin So any user that has access to this experience can use this function Now we'll load the game by win condition and we'll return null if we couldn't find it We'll also load the user vote and then we'll return this combined object The load game by condition will select all of these columns from the game joining to the answers and then it will return the data This is all standard drizzle and SQL So there's not too much crazy stuff going on Um one thing that we have here is we have the function to send an update given a game ID um via websocket So whenever we update the game we can send a message via websocket to notify all other clients on that experience that a new game the game has just been edited or has been published Actually the websockets part I'll include later in the video So we can use the load game function now to render the game on the front end To do that I'll get rid of most of this code here and replace it with some simplified code from our helper functions What we'll do first is we'll get the experience ID from the params and then we'll verify the user ID and get their access level Now we'll check if there's a game that already exists We can use the load game function from the server action that we just created If we have a game we'll return some game view that we can create as the next step If we don't have a game and we're an admin we'll return a creator empty state which will essentially redirect the creator to the admin page where they can create a game Otherwise the user is not an admin which means we'll just return a custom empty state Let's go and add these two components The creator entity state will redirect to the create screen and the custom empty state will just tell the customer that there's no games running right now and they should wait for the creator to add one Now the game view is where the magic happens Let's make this game view as a client component so it can be as interactive as possible In here we'll create a new file called game.client.tsx The first component we'll need is we'll need an answer option component to render each option that you can choose from So this will be rendering essentially an answer We'll import our type that we made in the load game And then we'll import a few helper functions like text is a frosted UI component to render text The users icon is from lucide react and the get percentage function is a helper that we've made here CN is a utility that combines clsx and tailwind merge to make managing conditional tailwind classes easier So we can just create that utility in a very simple file here Now that we can render each answer option let's render the game view So to render the game view I'm going to put the server game state that we fetch from the server into a used state so that we can update it on the client in response to websocket messages and user input We can render two boxes to show the total pool and the amount of players in the current game And we can render a card that shows the game question Now we can loop through all the answers and show each answer option This will be the game view One thing that NexJS is complaining about is the fact that this is not a client component We can make it a client component by adding use client to the top Now let's import the game view from our client file and render the page Let's see what we have here Now we can see that the total pool is $0 The amount of players is $0 And we can see the information pulled from the database that we created before Let's make this interactive and allow the user to select the current answer Before we do that let's go through all the possible game states that we could have and make sure that we can handle them in the UI To allow the user to vote we'll add a big CTA button at the bottom of the answer screen which tells the user what they can do And to figure out that text I'm going to make a helper function that will take in the current game state and print out the text that we should render and some information about what actions are available This CTA button text function will take in whether the current user is admin whether the game is completed what the correct answer ID is what the user has voted and their current selection and tell us what to render in the button CTA text Tell us what action we can do Return whether we can actually select an option and what color to render the button as This will just go through our game logic and make sure that we can show the right thing at the right time This will make our UI code simpler as well So we can just take the outputs and render them into the UI Now that we have this let's make this answer section a bit more powerful and extract it into its own component I'll add this answers section and replace our simple loop with the answers component Okay let's walk through this answers component We'll take in our array of answers and some information about the game And what we can do is work out our CTA button text here We can also have some state about the loading and the router for handling the action What we'll do here is we'll render the answer options just like we did before And then we'll render a submit button with a CTA text that we worked out The important thing is the handle submit function which is where we can handle submitting a vote handle revealing the answer handle ending the game and or creating a new game In the case of the creator this action is calculated by the CTA button text function which encapsulates all of our game logic Here the submit function and reveal answer function are not built yet So for now what we can just do is we can comment these out and come back to them later One thing we need to do is we need to make sure that we can actually set the current answer and update the game state That's why we put the game in the use state instead of just relying on the server action data which we can't easily update What I'm going to do is make some helper functions to set the game answer This will just update our game with the new answer that the user has selected We also need to make sure to import the router from next navigation Now we've added our CTA and it's showing the correct value for the admin How this game works is that the admin creates the questions The users answer the question The admin can end the bidding At that point the admin can then reveal the correct answer and that act of revealing will pay out the winners and resolve the game After that the creator can create a new game And all of that logic is contained within this CTA button text component What we now need to do is we need to implement these server actions to allow the game state to progress on the server Let's implement the first one called end bidding We'll make a new file called end bidding and implement the action on the server here What we do is we select the game make sure it exists make sure it hasn't been completed yet make sure that the user is an admin of that game experience ID update the game setting our completed app to the current time and then we'll send an update And sending this update is interesting because we're not just returning it to the current user but we want all instances of this view to update for every single player that's currently looking at the screen So to do that we can use websockets The W API has websockets built in So you can use a very simple function called W API send websocket message to send a message to every single user looking at that experience You can see how it's done by looking at this send update function This update function uses the game ID to load the game from the database make sure that it exists and if we found the game we'll send a JSON blob of the game to the experience ID that we're currently looking at So that'll be the game experience ID We'll also return the game so we can use it later Now how do we handle websocket messages well in the layout that we added earlier we added the websocket provider and we told it to join the experience ID that we're looking at This is verified by the server to make sure that only users that have access to the experience can join Now the W websocket provider will automatically connect to a websocket connection and reconnect in the case of failure and receive messages But how do we handle these messages what we can do is in our client component where we render the game where we have the game state here we can also listen to websocket messages We can use that by using the use on websocket message hook from the SDK This will return a message and that message has some properties This is how we can handle the message and we only want to handle the message if it's trusted There's two ways you can send websocket messages on W One of them is from the server which will mean that it's trusted It means that it's from your server was sent with your API key The other ways people can send websocket messages is using the use broadcast websocket message hook and this will return a function called broadcast message where you can send something for example on click from your client This is not verified by your server So any client could send it and potentially share false information but it allows you to very quickly broadcast information from clients like cursor positions and things like that We'll just listen to trusted messages to make sure that no one can hack our game We can pass this JSON as a game with votes which is the exact type that we send in this update function This is a game with votes So that way we'll make sure that our schema is in sync and then we can update the game with the combination of the old game which might includes our user vote answer ID and the new game The new game won't have the user vote answer ID at any point So we need to merge the old one in to persist that information That's because when we're broadcasting a message out to everyone we can't include different values of the message depending on the user that we're broadcasting to Now this will keep our instance of the view and everyone else's instance of the view in sync with the same game data Another strategy you can use to keep your game in sync is to just broadcast when an update happens and then refetch on the client But for some performance benefits we'll just do this way for now So let's add our end bidding function into our server action and we'll export it from here Now as a creator I can end the bidding and that will put me in a spot where I can select the correct answer Now let's say Brett won the typing condition This does nothing because we haven't revealed the answer yet So let's work on this function Next I'll make a new file called reveal answer and add our code in here In reveal answer again we will need to select the game We'll make sure that it exists We make sure that we don't already have a correct answer yet in which case it was already completed And we'll make sure that it was completed by endgame first Again we'll make sure that only admins can do this action And then we'll select the answer that the user provided When you reveal the answer you pass the answer ID We'll make sure that the answer exists And then we'll update our game by setting the correct answer ID Now we'll also send an update to sync that change to everyone else looking at the screen And we want to handle paying out the user So to pay out the user we'll pass in the game ID the answer ID and the experience ID Here what we want to do is we want to work out the total amount of money that was paid into this game and we want to split it between the winners So we'll need to find all the winners and send the money through the  API What we can do here is calculate the total pool sum by summing the received amount for all the votes from this game and that will make sure that we don't overcalulate the sum from money that was lost due to fees If no money was paid in we can't pay out Now what we'll do is we'll prepare paying out the funds via the W API For that what we'll do is we'll get our company ledger account which is the account that the funds will be paid into Once we have the account we'll subtract our transfer fee which is dependent on the account and we'll figure out the amount of money that we can send out Once we have that we'll select all the winners meaning the users that have a vote with the answer ID that's equal to the correct answer ID and we'll figure out if there were winners If there were no winners what we'll do is we'll send 80% of the money to the creator and we'll keep 20% of the money for ourselves as the app developer If there were winners then we'll send only 10% of the money to the creator The user payout will always be 80% of the total pool and the company payout will be 10% if there were users So if there were winners what we'll do is we'll use the payout per winner meaning the total pool size times 80% divided by the amount of winners One thing we need to do here is we need to make sure that this is never zero If this is zero we'll crash with a exception What we want to do is if winners.length is greater than zero we want to calculate how much money we're giving to each winner by taking 80% of the pool and dividing it by however many winners there were And we want to loop through all of them in parallel and pay them out using the WO API After that what we want to do is we want to pay out the winning company which means sharing some of the money made with the creator themselves So this way everyone gets paid The users that selected the correct answer get paid The creator gets paid as a percentage of the pot And you as the app developer also get paid for building the app and maintaining it which means you can run a business on as a developer as well Let's see how we can pay out the winner What we'll do here is we'll just use the WO API pay user function and make sure that we're paying them at least a dollar The minimum transfer amount is $1 will send the money in USD and we'll set an item potency key as the user ID and game ID This means that even if this code runs twice which it shouldn't we'll only end up doing this transaction once If a user somehow gets this to execute twice for the same game we won't end up paying them twice which means we won't lose out any money The ledger account ID here needs to be our company ledger account which we were able to fetch up here And we can give a note why we paid them out And the destination ID will be their user ID We'll also pass our Ledger account transfer fee in here which matches this account Paying out a company is essentially the same except we'll need to fetch the company ID So given an experience ID we can turn that we can fetch information about the experience and return the company that that experience is on Again we'll make sure the amount is greater than one and we'll pass the company ID and game ID as the item potency key Now we've handled revealing the answer and paying out the winners in a less than 200 lines of code Now how do we actually pay in money as a user for that we can use the charge user method and the inapp purchase iframe method on the client to handle the endto-end flow of doing inapp purchases on Bob In our client SDK we can now import this method and we can work on the vote action which allows users to vote on the correct answer while the game is in the voting phase So for that we'll need to get this inapp purchase object and we can get that from the submit vote function The submit vote function will again be a server action that we can use on the server to verify that the current user has access to the experience and create a charge object that we can complete on the client We'll create a new file called submit vote and we'll add our server action here This server action selects the current game for the provided answer ID It makes sure that the game is not yet completed So the game is in the bidding phase Now we'll check the access level and we'll get the user ID of the current user Here we'll ensure that the user is not an admin Admins can only progress the game but they can't vote and users can only vote but they can't progress the game We'll find if there's any existing votes for that user for that game And if there is we'll just return You can't vote twice Once we've verified all of the information we'll call W API.charge user In this call we'll use the game answer cost as the amount that we want to charge them We'll always charge in USD We'll pass the user ID of the user that we want to charge aka the person that's submitting the answer which we've got from the verify user call What we can also do is we can pass metadata into the game Passing metadata allows us to read this metadata in web hooks about this charge which will get sent async to our application We'll set those up in a second If the charge user is successful we'll return the inapp purchase object from that APL call back to the client We can now import the submit vote function passing our selected answer ID Now we have the inapp purchase object and we can pass this to the W iframe SDK inapp purchase function Once that succeeds this function will open a modal with a checkout form and allow the user to pay with all available payment methods After this completes in the UI we can set the answer to the selected answer ID Setting this answer here will call this method up here and update the game optimistically Meanwhile on the back end we'll need to handle the web hooks correctly To handle web hooks on what we'll need to do is we'll set up our web hooks in the W dashboard We'll copy the web hook secret and then we'll handle them in an API route in next.js Let's do that right now What we'll do is we'll go to the web hook section of the app developer dashboard on W Just as a reminder to help you find this you open your dashboard here You click on developer here and then you click on your app here After you've done that you can go to the web hook section and you can create your first web hook Make sure to select API version v5 And now you can add your endpoint URL For this I'll use the URL that we've deployed on on Versel What we can do here is we can grab that from our project We can grab the URL from our project by copying the link that Versell gives us We can paste it here and we can say that we want web hooks on / API/webhooks and we want to know about the payment succeeded web hook This will fire when a user completes checkout on a resource that's related to our app So this will allow us to get notified through a trusted server to server event when the user completes checkout We'll hit save and then we can copy the web hook secret from this table We can always edit the URL here and update the path Let's go back to the app and add our web hook The template already comes with the API web hooks path configured and a route that shows you how to handle web hooks You'll see here that we need the web hook secret in our environment To add this I'm going to go to versel I'm going to add it there and then pull my environment locally Again I'm going to head to settings Going to go to environment variables I'm going to add it in here Work secret After I hit save I'm going to stop my development server and run the cell environment Now we can see that this has added the web hook secret I'll start the dev server again Now that we're up and running again what we can do is we can add our web hook handler here To do that I'll paste in this function that will handle the web hook for our game What we'll also do is we'll extract some more information from the web hook and call the handle web hook function in here Validating the web hook from the request will ensure that only w.com can send you the web hook data and not some hacker that's pretending to be w.com This uses the web hook secret After that we'll make sure that the web hook that we received is the payment succeeded one we started listening for And then we'll extract the data that we need from the web hook The web hook comes with a receipt ID a final amount which is the amount the user paid and an amount after fees which is the amount that you receive after Stripe fees and other payment fees are taken out The currency is the currency the user paid in So this will match the currency that you set in the charge user call here The final amount will match the amount that you specify here and the user ID is obviously the user ID that paid the receipt and the metadata will match the metadata object that you passed in Now once we've extracted this information we can log for our sanity and then we can handle the data So here we'll make sure that the metadata contains an answer ID and a game ID Make sure those are strings and exist in the metadata Make sure that there's a user ID We'll make sure that amount after fees is not null and then we'll ensure that the currency is USD If any of these cases are not true we'll error and we won't handle the web hook We need to do this because we'll receive web hooks for many different types of payments that succeed So we'll just want to filter out ones that actually relate to our game and not another event You can also handle those web hooks and do actions in response to those if you want Once we've validated everything we can convert the amount after fees into a number and we can insert into the votes table that this user has voted this answer for this game and they paid this amount and we received this amount after fees Now what we can do is we can use the wait until to do some actions after handling this web hook The reason we all use wait until is to do potentially longer running async tasks after we've responded to the request with a 200 status code If we don't do this and our request takes very long to resolve then the API will think that the request failed and it will retry it up to four times After voting what we'll do is we'll send an update about the game via websocket to keep everyone's screen up to date and live And then we'll also send a push notification to everyone that a new player has submitted a vote This should keep everyone engaged and more people voting Now that we're handling web hooks we have a complete game Let's push this up to Versel and deploy it live Then we can run through an end toend test To push to Versel I'll just commit all of our changes and I'll sync them with git This will trigger a new deployment on Versel and deploy everything live Since we're syncing the environment variables all the secrets should be correct both in production and in development We can monitor the status of our deployment on the cell here And we'll switch to production once it's live Let's run through an end toend test of the entire app As a creator I'll come on and I'll create a question such as who will make the best app I'll say that it costs $3 to answer and I'll give the options of Connor or Steven Now we can create the game As a user in my notifications I should have received a new notification that a game was started I can click on this game and once it loads I can answer So I can select Steven in this case Let me submit the answer This will pop up a new charge for $3 which is the answer price that we've selected Once I've paid you can see that via websocket the total pool count has increased to $3 and the amount of players who won I can see on the admin side that this information is updated live as well through the websocket So one player $3 in the pool one vote for Steven Now let's end the bidding phase Once I end the bidding phase the client state updates to waiting for the big reveal I can select the correct answer Let's select Steven as the correct answer I'll submit the correct answer and this will pay out all the users Here I can see that I've received a message that I've been paid out for winning the game Of course I get paid out less than $3 Since some money is lost to payment processing fees some money was sent to the creator of the game and some money was kept by the app developer As you can see with more and more people this becomes a profitable and fun game to play Especially for you as an app developer and the creator that installs it and runs it with their users Let's make sure that our app is ready to go and ready to publish on the app store So what we can do is we can go to the dashboard and go to the app details section and we can fill out the required information So let's add a description here We'll upload a game icon and we'll choose a category We'll put it in the games category Then we'll hit save Once we refresh we've done all the requirements for the app store So we can publish One thing we should do here is we should enable the automation that allows us to message any creator that installs our app So we can hit save here And this means that creators will get a DM from us as the app developer when they install their app This allows you to reach out automatically to creators and make sure they have a good experience and gives them a channel where they can submit feature requests and bugs which will just end up making your app better and better Once we're done we can hit publish to the app store and this will mean that our app is now in review and will appear on the app store very soon All of this code is open source and available on our GitHub repo link in the description Also join our developer community at wp.com/developers to get ideas and help when you're building your new app Excited to see you there Bye 